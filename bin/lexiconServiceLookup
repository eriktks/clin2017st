#!/usr/bin/perl -w
# lexiconServiceLookup: lookup word(s) on the INL Lexicon Service (find lemma)
# usage: lexiconServiceLookup < file
# note: input file contains one word per line
# 20160831 erikt(at)xs4all.nl

use strict;

my $command = $0;
my $url = "http://sk.taalbanknederlands.inl.nl/LexiconService/lexicon/get_lemma?database=lexicon_service_db\&case_sensitive=false\&wordform=";

# read and process words
while (<STDIN>) {
   my $line = $_;
   chomp($line);
   sleep(1);
   my $hline = $line;
   $hline =~ s/'/%27/g;
   if (not open(INFILE,"curl -s -o - '$url'$hline |")) {
      die "$command: cannot access lexicon service with curl!\n";
   } else {
      my $word = $line;
      print $word;
      my %t = ();
      while (<INFILE>) { 
         my $line = $_;
         chomp($line);
         my @tokens = split(/([<>])/,$line);
         for (my $i=2;$i<=$#tokens;$i++) {
            if ($tokens[$i-2] eq "lemma" and $tokens[$i-1] eq ">") {
               $t{$tokens[$i]} = defined $t{$tokens[$i]} ? $t{$tokens[$i]}+1 : 1;
            }
         }
      }
      close(INFILE);
      foreach my $t (sort { &sortT($t{$a},$t{$b},$a,$b,$word) } keys %t) {
         print " $t $t{$t}";
      }
      print "\n";
   }
}
exit(0);

sub sortT() {
   my ($ta,$tb,$a,$b,$token) = @_;
   if ($tb != $ta) { return($tb <=> $ta); }
   else { 
      my $la = &levenshtein($a,$token);
      my $lb = &levenshtein($b,$token);
      if ($la != $lb) { return($la <=> $lb); }
      else { return($a cmp $b); }
   }
}

# levenshstein code: source: http://www.perlmonks.org/?node=Levenshtein%20distance%3A%20calculating%20similarity%20of%20strings

sub levenshtein
{
    # $s1 and $s2 are the two strings
    # $len1 and $len2 are their respective lengths
    #
    my ($s1, $s2) = @_;
    my ($len1, $len2) = (length $s1, length $s2);

    # If one of the strings is empty, the distance is the length
    # of the other string
    #
    return $len2 if ($len1 == 0);
    return $len1 if ($len2 == 0);

    my %mat;

    # Init the distance matrix
    #
    # The first row to 0..$len1
    # The first column to 0..$len2
    # The rest to 0
    #
    # The first row and column are initialized so to denote distance
    # from the empty string
    #
    for (my $i = 0; $i <= $len1; ++$i)
    {
        for (my $j = 0; $j <= $len2; ++$j)
        {
            $mat{$i}{$j} = 0;
            $mat{0}{$j} = $j;
        }

        $mat{$i}{0} = $i;
    }

    # Some char-by-char processing is ahead, so prepare
    # array of chars from the strings
    #
    my @ar1 = split(//, $s1);
    my @ar2 = split(//, $s2);

    for (my $i = 1; $i <= $len1; ++$i)
    {
        for (my $j = 1; $j <= $len2; ++$j)
        {
            # Set the cost to 1 iff the ith char of $s1
            # equals the jth of $s2
            # 
            # Denotes a substitution cost. When the char are equal
            # there is no need to substitute, so the cost is 0
            #
            my $cost = ($ar1[$i-1] eq $ar2[$j-1]) ? 0 : 1;

            # Cell $mat{$i}{$j} equals the minimum of:
            #
            # - The cell immediately above plus 1
            # - The cell immediately to the left plus 1
            # - The cell diagonally above and to the left + the cost
            #
            # We can either insert a new char, delete a char of
            # substitute an existing char (with an associated cost)
            #
            $mat{$i}{$j} = min([$mat{$i-1}{$j} + 1,
                                $mat{$i}{$j-1} + 1,
                                $mat{$i-1}{$j-1} + $cost]);
        }
    }

    # Finally, the distance equals the rightmost bottom cell
    # of the matrix
    #
    # Note that $mat{$x}{$y} denotes the distance between the 
    # substrings 1..$x and 1..$y
    #
    return $mat{$len1}{$len2};
}


# minimal element of a list
#
sub min
{
    my @list = @{$_[0]};
    my $min = $list[0];

    foreach my $i (@list)
    {
        $min = $i if ($i < $min);
    }

    return $min;
}
